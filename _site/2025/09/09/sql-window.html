<!DOCTYPE html>
<html lang="en">
   
  <head>
               
    <meta charset="UTF-8" />
               
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
               
    <title>SQL Window Functions - A Beginner to Intermediate Guide</title>
               
    <link rel="icon" type="image/png" href="/assets/will.png" />
               
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css"
    />
       
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
    />
       
    <link rel="stylesheet" href="/assets/styles.css" />
     
  </head>
   
  <body>
           
    <video autoplay muted loop playsinline id="video-background"></video>      
          <header>
  <nav class="custom-header">
    <div class="header-content">
      <a class="logo-link" href="/">
        <figure class="image is-32x32">
          <img
            class="is-rounded-will"
            src="/assets/will.png"
            alt="William's Blog"
          />
        </figure>
      </a>

      <div class="header-right">
        <div class="nav-links">
          <a href="/about.html">
            <span class="icon"><i class="fas fa-info-circle"></i></span>
            <span>About</span>
          </a>
          <a href="/blog.html">
            <span class="icon"><i class="fas fa-blog"></i></span>
            <span>Blog</span>
          </a>
          <a href="/contact.html">
            <span class="icon"><i class="fas fa-envelope"></i></span>
            <span>Contact</span>
          </a>
        </div>

        <a
          role="button"
          class="navbar-burger"
          aria-label="menu"
          aria-expanded="false"
          data-target="navMenu"
        >
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>

        <div id="navMenu" class="navbar-menu"></div>
      </div>
    </div>
  </nav>
</header>
        
    <main class="content-container">      <div class="content-container">
  <div class="paper-container">
    <nav class="level is-mobile post-nav-links">
      <div class="level-left">
        
        <a href="/2025/09/08/what-is-rag.html" class="button post-nav-button">
          <span class="icon is-small"><i class="fas fa-arrow-left"></i></span>
          <span>Prev Post</span>
        </a>
        
      </div>
      <div class="level-right">
        
        <a href="/2025/09/09/CTE.html" class="button post-nav-button">
          <span>Next Post</span>
          <span class="icon is-small"><i class="fas fa-arrow-right"></i></span>
        </a>
        
      </div>
    </nav>

    <h1 class="title is-2 post-title">SQL Window Functions - A Beginner to Intermediate Guide</h1>

    <div class="post-meta">
      <p>Written by William Golovlev on September 09, 2025</p>
    </div>

    
    <figure class="image post-figure">
      <img src="/assets/blog-images/5.png" alt="SQL Window Functions - A Beginner to Intermediate Guide" />
    </figure>

    <div class="content post-content"><p>SQL window functions are one of the most powerful tools in a data analyst’s arsenal, allowing you to perform calculations across a set of table rows that are somehow related to the current row. Unlike aggregate functions (like SUM() or COUNT()), which collapse rows into a single summary row, window functions perform a calculation and return a value for each row in the result set.</p>

<p>The core syntax for any window function is the OVER() clause. This is what transforms an ordinary aggregate function into a window function.</p>

<ol>
  <li>The Basics: OVER() and Partitions</li>
</ol>

<p>The OVER() clause is where you define the “window” or set of rows the function will operate on. It can be empty, or it can contain two important clauses: PARTITION BY and ORDER BY.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PARTITION BY: This clause divides your data into separate groups, or "partitions." The window function is then applied independently to each partition. This is similar to a GROUP BY clause, but it doesn't collapse the rows.

ORDER BY: This clause orders the rows within each partition. This is crucial for ranking functions and for sequential calculations like running totals.
</code></pre></div></div>

<p>Basic Syntax:
SQL</p>

<p>WINDOW_FUNCTION() OVER (
PARTITION BY column1, column2, …
ORDER BY column3, …
)</p>

<ol>
  <li>Beginner’s Toolkit: Ranking and Value Functions</li>
</ol>

<p>These are a great starting point for understanding how window functions work.</p>

<p>a. Ranking Functions 🏆</p>

<p>Ranking functions assign a rank to each row based on the specified order.
Function Description Example Use Case
ROW_NUMBER() Assigns a unique, sequential integer to each row within the partition. Ranking products by sales within a region.
RANK() Assigns the same rank to rows with the same value, then skips the next rank. Finding the top 3 students by score, where ties get the same rank.
DENSE_RANK() Assigns the same rank to rows with the same value, but does not skip the next rank. The same as RANK(), but without gaps in the ranking.
NTILE(n) Divides rows into n groups and assigns a group number. Splitting customers into four quartiles based on spending.</p>

<p>Example:
Imagine a sales table. To rank products by sales amount within each region:
SQL</p>

<p>SELECT
product,
region,
amount,
ROW_NUMBER() OVER(PARTITION BY region ORDER BY amount DESC) AS regional_rank
FROM
sales;</p>

<p>b. Value Functions ➡️</p>

<p>These functions let you access a value from a preceding or succeeding row in your window. They are essential for comparing a row to a previous or next one, often in time-series data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LAG(column_name, offset, default_value): Retrieves a value from a row before the current row. offset is how many rows back you want to look, and default_value is what to return if there's no row.

LEAD(column_name, offset, default_value): Retrieves a value from a row after the current row.
</code></pre></div></div>

<p>Example:
To find the difference in sales amount from the previous sale:
SQL</p>

<p>SELECT
sale_date,
amount,
LAG(amount, 1, 0) OVER(ORDER BY sale_date) AS previous_amount,
amount - LAG(amount, 1, 0) OVER(ORDER BY sale_date) AS amount_difference
FROM
sales;</p>

<ol>
  <li>Intermediate Toolkit: Advanced Aggregates and Window Frames</li>
</ol>

<p>Once you’re comfortable with the basics, you can unlock the true power of window functions.</p>

<p>a. Aggregate Functions as Window Functions 📊</p>

<p>You can use standard aggregate functions like SUM(), AVG(), MIN(), and MAX() as window functions by adding OVER(). The key is defining the window to get a running total or rolling average.</p>

<p>Example: Running Total
To calculate the cumulative sales total over time:
SQL</p>

<p>SELECT
sale_date,
amount,
SUM(amount) OVER(ORDER BY sale_date) AS running_total
FROM
sales;</p>

<p>Without a PARTITION BY, this calculates the running total across the entire table.</p>

<p>b. Window Frames: ROWS and RANGE</p>

<p>This is a more advanced concept that gives you granular control over the “window” of rows an aggregate function operates on. It defines a subset of the partition.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ROWS: Defines the window based on a number of physical rows.

RANGE: Defines the window based on a range of values within the ORDER BY column.
</code></pre></div></div>

<p>Common keywords include PRECEDING, FOLLOWING, and CURRENT ROW.</p>

<p>Example: Rolling Average
To calculate the average sales for the current day and the previous two days:
SQL</p>

<p>SELECT
sale_date,
amount,
AVG(amount) OVER(
ORDER BY sale_date
ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
) AS three_day_avg
FROM
sales;</p>

<p>The ROWS BETWEEN 2 PRECEDING AND CURRENT ROW clause tells the function to look at the current row and the two rows before it within the ordered partition.</p>

<p>Conclusion</p>

<p>Window functions are incredibly versatile and can simplify complex calculations that would otherwise require cumbersome subqueries or self-joins. By mastering the core syntax—OVER(), PARTITION BY, and ORDER BY—and then graduating to more advanced concepts like window frames, you’ll be able to solve a wide range of analytical problems with concise and efficient SQL code.</p>

<p>Ready to start practicing? Try DataLemur.com for some nice datasets and practice.</p>
</div>
  </div>
</div>
    </main>
                   
    <script src="/assets/script.js"></script>
     
  </body>
</html>
